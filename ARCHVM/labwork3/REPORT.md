| Лабораторная работа №3 | M3101 | АОВС |
| ---------------------- | ----------- | ---- |
| Кеш и кодирование команд   | Хрусталев Николай Дмитриевич       | 2024 |


## Что реализовано
Было реализовано вытеснение lru, а также перевод ассемблера в машинный код

## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-Khrustalion/actions/runs/9082093324)

# Описание
### ISA:
Для начала в некоторые регистры были записаны необходимые константы: ```M -> t0```, ```N -> t1```, ```K -> t2```. Это было сделано с помощью функции ```addi```, которая в берет значение из регистра, прибавляет к нему число и записывает в другой регистр (в качестве первого регистра, из которого берется значение, был взят регситр ```zero``` - регистр, в котором всегда лежит 0). Аналогичным образов были загружены адреса начала массивов ```A - > s1```, ```B -> a0```, ```C -> a1```. Адрес начала массива А равнен 256, так как по условию лабораторной с этого адреса могут начинатся данные. Далее считаем значение ```M * K```(умножение считаем с помощью операции ```mul```. Она берет значения из двух регистров и записывает в третий результат умножния этих чисел), так как именно столько байт занимает массив А и прибавляем это число к адресу начала массива А. Таким образом получили массив В. Аналогично считаем ```2*K*N```(тут 2, так как в массиве В будут лежать двухбайтные числа), прибавляем к адресу начала массива В и получаем адрес начала массива С.
Чтобы получить указатель ```pa```  и ```pc```, берем значения из регистра с адресом начала массива ```A``` и ```C``` и прибавляем к ним 1. Таким образом в новом регистре будет адрес начала данных массивов.
Далее начинается цикл ```for y```. Чтобы его реализовать заведем счетчик(регистр), который изначально будет равен 0 и постепенно будем его увеличиваеть после выполнения всех операций внутри цикла. Аналогично заводим счетчик для ```x```.
Далее получаем указатель ```pb``` и заводим новую переменную ```S``` равную 0.
Далее начинается цикл ```for k```. 
Чтобы получить значение ```pa[x]``` мы должны сначала найти порядковый номер этого байта: ```pa + x``` и затем с помощью команды ```lb``` получить значение байта по такому адресу(```lb``` записывает в регистр байт, который находится по адресу, равному сумме 2 регистра и константы)
Чтобы получить значение ```pb[x]```, надо для начала получить ```2*x```, так как в ```pb``` хранятся двухбайтные числа. Далее аналогично получаем значение ```pb[x]``` c помощью команды ```lh```(работает аналогично команде ```lb```, только возвращает двухбайтное число)
Получаем значение ```pb[x] * pa[x]``` с помощью команды ```mul``` И прибавляем это к регистру ```s```.
Чтобы прибавит ```N``` к ```pb``` нужно также сначала получить значение ```2*N``` и прибавить это значение к регистру ```pb```.
Инкрементирум регистр ```k``` с помощью команды ```addi```, где в качестве константы передаем 1.
Далее идет проверка ```k < K``` и в зависимости от этого делаем прыжок назад(если условие выполняется). Прыжок идет на строку, следующую за строкой, где определен счетчик для ```k```(строка с комментарием ```k, for k```).
Чтобы получить значение ```pc[x]``` необходимо для начала получить значение ```4*x```, так как в ```pc``` хранятся четырехбайтные числа. C помощью команды ```sw``` сохраняем значение регистра ```s```.
Далее идут инкрементирование регистра ```x``` и проверки ```x < N```.
Чтобы получить значение ```pc + N``` необходимо для начала получить значение ```4*N```, так как в ```pc``` хранятся четырехбайтные числа. Прибавляем это значение к регистру ```pc```
После этого идут аналогичныне инкерментирование и проверка на ```y < M```.
### Машинный код
Для реализации ```asm->binary``` реализована функция ```getByteCode``` внутри класса ```Simulate```. В этой функции циклом проходятся все команды и ветвлением определяется текущая команда. Для команд реализованы функции ```getCode[X]Reg```, в которой в зависимости от количества регистров выполняется построение кода для текущей команды. У каждой команды есть постоянный код, который описывает саму команду(То есть полный код этой команды для любых регистров и констант будет содержать некоторые биты, которые не зависят от этих регистров и констант). Таким образов в эти функции ```getCode[X]Reg``` передаются эти неизменяющиеся биты и регистры(в некоторые еще подаются константы) и в зависимости от количества регистров и некоторых других входных параметров вычисляется машинный код. После этого этот код записывается в файл с помощью команды ```writeCode```, которая записывает этот код в 16-ричной системе побайтно.

### Cache:
| Параметр    | Значение | Формуле расчета |
|-------------|----------|-----------------|
| MEM_SIZE    | 262144   | 2^ADDR_LEN      |
|CACHE_TAG_LEN| 8        | ADDR_LEN - CACHE_INDEX_LEN - CACHE_OFFSET_LEN |
| CACHE_INDEX_LEN | 5 | log_2(CACHE_SETS) |
| CACHE_OFFSET_LEN | 5 | log_2(CACHE_LINE_SIZE) |
| CACHE_SIZE | 4096 | CACHE_LINE_COUNT * CACHE_LINE_SIZE |
| CACHE_LINE_COUNT | 128 | CACHE_SETS * CACHE_WAY |

- Для реализации кеша были созданы несколько классов:
```CacheLine``` - класс кеш линии. Внутри этого класса есть поля ```data```(поле для хранения данных кещ линии), ```used```(булево поля, для отображения использованности кещ линии, если ```used``` -  true, то кеш линия использутеся, инче нет), ```tag```(для хранения тега данных, которые хранятся внутри кеш линии), ```flag```(для политики вытиснения). 
```CacheBlock``` - класс для кеш блока. Внутри этого класса хранится массив из кеш линий. Их количество равно ```CACHE_WAY```.
Сам кеш реализован внутри класса ```Processor```. Внутри него есть массив ```cache```, который хранит ```CacheBlock```. Их количество равно ```CACHE_SETS```
Для вставки данных в кеш реализована функции ```InsertInCache``` внутри класса ```Proccesor```. Этой функции предеается адрес, который необходимо вставить. Достает ```Index``` из этого адреса и проверяет все кеш линии, которые находтся внутри блока с этим индексом. Если находится неисползованная кеш линия, то поиски прекращаются, иначе находится кеш линия с самым большим значением ```flag```. Если найденная кеш линия уже была использована, то небоходимо перенести данные в оперативную память(так работает write-back). Для этого получаем старый адрес(для этого необходимо взять тег из этой кеш линии, сдвинуть его на ```CACHE_OFFSET_LEN + CACHE_INDEX_LEN``` байт и прибавить индекс, полученный из начального адреса сдвинутый на ```CACHE_OFFSET_LEN``` байт) и по этому адресу переносим данные из кеш линии в оперативную память.
После этого переносим данные из оперативной памяти в кеш линию, меняем данные у этой кеш линии (флаг ```used```, ```flag``` ```tag```).
После этого обновляем флаге у всех использующихся кеш линий внутри кеш блока. Обновление происходит с помощью функции ```updateFlag```. Она принимает в качестве аргументов индекс и значение флага. В этой функции увеличатся значения всех флагов(у всех исползующихся кеш линий) со значением меньшим, чем значения флага в аргументе. Значение кещ лини с флагом, равным флагу в аргументе приравнивается к 0, так как эта подразумевается, что эта кеш линия только что использвоалась и ее приоритет должен равняться 0.

Реализована функция `findInCache`. Функция принимает адрес и вычисляет по нему индекс и тег. Далее проходит все кеш линии внутри блока с данным индексом и проверяет на равенство теги. Если такая кеш линия есть, то возварщает ее номер, если такой нет, то -1.

Релизованы функции ```Store``` ```Load``` для различных размеров. Рассмотрим для `loadByte`: для начала вычислим значения индекса, тега и сдвига. Далее с помощью функции `findInCache` узнаем, есть закеширован ли данный адрес. Флаг `calc` помогает понять, нужно ли считать попадания и промахи в кеш. Так как при вызове от, напримаер, `loadByte` вызывается `loadByte`, но при таком вызове не надо считать попадания и промахи. Если `findCache` вернул не -1, то значит данные по этому адресу в кеше и было попадание(Возвращаем данные по адресу из кеша). Если адрес не попал в кеш, то вызваем ``InsertInCache`` и вставляем этот адрес в кеш.
`loadByte` работает аналогично. проверяем, что оба байта лежат в кеш линии. Если хотя бы один байт не попал, то был промах.  Если это тако, до формируем 16 байтное число с помощью 2 функций `loadByte` и возвращаем. 
`loadHalf` работает абсолютно аналогично, только проверяются 4 адреса.
`storeByte` есть небольшие изменения. Если данный адрес не лежит в кеше, то надо его вставить в кеш. Поэтому если произошел промах, то вызываем функцию `insertInCache`.

Симулция происходит в классе `Simulate` с помощью функции `simulate`. Есть указатель `pc` - указатель на комнаду. Есть вектор с командами, который был получен при парсинге файла с кодом на ассемблере. Там хранятся только названия команд, регистры и константы в виде строк. Внутри симуляции есть цикл `while`, который работает до тех пор, пока указатель `pc` не будет равен длине массива с командами. Внутри этого цилка происходит ветвление по первому аргументы их текущей команды - название команда на `RISC-V`. И в зависимости от названия команда вызвается одноименная функция. Все эти функции реализованы внутри класса `Simulate`

| replacement | output lru | output Plru | 
|:-:|:-:|:-:|
| 0 | 0.9912% | pLRU    unsupported |
|1| 0.9912% | |
|2|| pLRU    unsupported |
