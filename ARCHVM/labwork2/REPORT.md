| Лабораторная работа №2 | M3101 | АОВС |
| ---------------------- | ----------- | ---- |
| Работа со схемами   | Хрусталев Николай Дмитриевич | 2024 |

## Инструментарий

> Icarus Verilog version 12.0 (stable)

## Вариант

> logisim lit
> behaviour verilog normal


## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-circuit-Khrustalion/actions/runs/8403285256)


# Описание

## Logisim

В работе были использованы как ```rs-trigger```, так и ```jk-trigger```. ```rs-trigger``` был использован для создания ячеек памяти в самом стеке (всего 7 триггеров по по одному на каждую ячейку). ```jk-trigger``` всего один для сохранения номера вершины стека.

На ```comand``` стоит демультиплексор, имеющий 3 провода на выходе:

| входные данные | 1 провод | 2 провод | 3 провод |
|--|--|--|--|
|00|0|0|0|
|01|1|0|0|
|10|0|1|0|
|11|0|0|1|

1 провод идет к схеме ```push```, 2 провод идет к схеме ```pop```,  провод идет к схеме ```get```.

```current_cell``` - ```jk-триггер```, который указывает на ячейку памяти, следующую за вершиной стека (то есть если при данные положили в ячейку с номером 2, то ```current_сell``` указывает на ячейку с номером 3, аналигочно если данные при pop получили из ячейки с номером 2, то ```current_cell``` будет указывать на эту ячейку с номером 2). ```jk-триггер``` реализован стандартно, с помощью двух ```rs-trigger```

```jk-триггер``` использован, чтобы избежать возбуждения. Данные туда кладуется по заднему фронту, то есть если данные пришли по переднему фронту, то эти данные будут положены в конце такта. Данные обновляются с помощью одной из схем. Эти схемы соответсвуют названиям операций: ```push```, ```pop``` и ```get```. Каждый из них имеет провод, для получения текущих данных из ```current_cell```, далее эти данные обновляются(далее будет подробнее описано с помощью чего) и провод вывода, который подается обратно в ```current_cell```. Каждый из этих проводов пропускается через ```and```, где второй провод идет от демультиплексора ```comand``` (провод соответсвующий команде ```comand```).

К каждому из выходов ```data[i]``` подключен ```memory_cell``` для сохранения данных, которые будут класть при операциях.

### memory_cell
Схема, созданная для хранения данных стека. На вход подает четырехбитное число, ```clk``` и ```state```, где ```state``` - это флаг, с помощью которого мы пониимаем, надо ли записывать текущие данные в эту ячейкку или нет. Сама схема состоит из 4 ```rs_trigger``` к каждому из которых проведен провод от входного четырехбитного числа. На вход ```r``` подается значение провода, пропущенное через инвертор. Это сделано для того, чтобы правильно записывать данных в ```rs_trigger```. На вход ```s``` подается прямой значение бита. Таким образом данная сзема позволяется сохранять данные, состоящие из 4 битов.

### схема and14

Схема имеет 2 входа: 1 четырехбитное число и отдельный проводок ```d1```. Если провод на ```d1``` есть напряжение, то на выходе будет то же четырехбитное число, что и на входе. Если же на ```d1``` нет напряжения, то на выходе всегда будет 0.

### demultiplexer8

на входе 3 провода, а на выходе 8. Напряжение подается на провод  номером соответсвующий числу на входе (3 провода образуют трехбитное число)

Схема:

| входные данные | o_0 | o_1 | o_2 | o_3 | o_4| o_5 | o_6 | o_7 |
|--|--|--|--|--|--|--|--|--|
|000|1|0|0|0|0|0|0|0|
|001|0|1|0|0|0|0|0|0|
|010|0|0|1|0|0|0|0|0|
|011|0|0|0|1|0|0|0|0|
|100|0|0|0|0|1|0|0|0|
|101|0|0|0|0|0|1|0|0|
|110|0|0|0|0|0|0|1|0|
|111|0|0|0|0|0|0|0|1|

### схема push
Как было описано выше, на входе имеет три провода, которые идут из ```current_cell```. Это значение скалдывается с еще одним проводом, который идет от демультиплексора ```comand```. Скалдывается с помощью схемы ```summer_1_3```(реализован с помощью 3 ```half_summer```. Имеет 4 входа: 3 от трехбитного числа и один, с которым это число складывается. Самый незначащий бит из 3 складывается с отдельным битов, остальные скалдываются с переносом от предыдщих вычислений)

схема для ```half_smmer```:
|a|b|r|c|
|--|--|--|--|
|0|0|0|0|
|0|1|1|0|
|1|0|1|0|
|1|1|0|1|

Результат сложения выводится из схемы и подается на вход ```current_cell```

этот же результат идет дальше в ```demultiplexer8```



Каждое из этих значений проходит через схему and14, где в качестве четырехбитного числа выступает еще один вход, которое получает эти данные из ```IDATA```. Соответвенно есть 8 выходов ```d[i]```, которые далее записываются в соответствующие ячейкам памяти стека. Также с каждым ```d[i]``` выходит провод ```s[i]```, значение на котором получается путем применения операции ```and(o_[i], c)```, где ```c``` - провод от демультиплексора ```comand```.  ```s[i]``` - провод, который предотвращает случайную запись в ячейку: запись будет вестись только в ту ячейку, которая соответсвует текущему значению ```current_cell```.

### схема pop
на входе имеет три провода, которые идут из ```current_cell```. Из этого значения вычитается еще один провод, который идет от демультиплексора ```comand```. Вычитается с помощью схемы ```substractor_1_3```

Результат вычитания выводится из схемы и подается на вход ```current_cell```

этот же результат идет дальше в ```demultiplexer8```.

Схема также имеет 8 входов для четырехбитных чисел - числа, соответсвующие ячейкам памяти стека. Каждый из них проходит через схему ```and14``` (в качестве отдельного бита провод, выходящий из ```demultiplexer8```, с соответсвующим номером). В итоге образуются 8 четырехбитных проводов. Все они прохожят через опреацию ```or```, имеющая 8 четырехбитных  входов. В итоге получается один выход, который пропущен через схему ```and14```, где в качестве отделного бита взят от провода, оторый идет от демультиплексора ```comand```. Это предотвращает случайный вывод данных в ```ODATA```(то есть вывод не осуществляется, если не дана команда pop). Итоговый провод соединен с ```ODATA```.

### схема substractor_3_3
На вход подаются два трехбитных провода. Сначала вычитаются два наименьших бита с помощью ```half_substractor```, затем остальные биты попарно вычитаются с помощью двух ```substractor```, где в качестве переноса выступает перенос, полученных на прошлых шагах(то есть для первого ```substractor``` берем перенос из ```half_substractor```, а для второго берем перенос из первого ```substractor```)
из каждого ```[half_]substractor``` выводится провод и в результате на выходе имеем 1 трехбитное число - результат вычитания.

схема для ```half_substractor```:
|a|b|d|b|
|--|--|--|--|
|0|0|0|0|
|0|1|1|1|
|1|0|1|0|
|1|1|0|0|

Аналогично 

### схема get
Схема аналогична схеме ```pop```, за исключением использования ```substractor_1_3```. Вместо него используется схема ```substractor_3_3```. 
Еще одно различие состоит в том, что на выход мы подаем не обновленные значения, а те, которые пришли нам изначально. Так как ```get``` не меняет указателя на текующую ячейку, то необходимо выводить старое значение и подавать его на вход ```current_cell```.

Все данные, полученные из схем ```pop```, ```get``` и идущие к ```ODATA```, пропущены через схему ```and14```, где в качестве отдельного проводы выступет провод от ```clk```. Это сделано для того, чтобы запись производилась только в те моменты, когда значение на ```clk``` равно 1.

### Reset

Провод от ресет идет к каждой из ячеек и с помощью операции ```or``` вместе с одним из ```s[i]```, выведенных из схемы ```push```, заводится значения в ```memory_cell```. Также обратное значение ```reset``` "блокирует" данные из ```push```: это обратное значение пропущено через схему ```and14```, где в качестве четырехбитного чила выступают  данные, полученные из  ```push```. Таким образом при включенном ```reset``` все ячейки открываются на запись и во все ячейки записываются нули.


## Stack behaviour
Все значению в памяти стека хранятся в регистрах, также как и указатель на текущую ячейку. Все синхронизации идут путем выполнение операции always, где в качестве аргумента передается "переднаяя сторона ```clk```, так называмый фронт. Таким образом идет синхронизация по фронтую.
Для начала подключим входо-выход (всегда, когда он будет использоваться, как выход будем подавать на него высокоимпедансное состоние, иначе нули). 
Далее идет инициализация ячеек памяти и некоторых переменных(указатель на текущую ячейку)
В отдельный блок always вынесена проверка на reset = 1. Данное условие проверяется всегда, на протяжении работы всей программы. Если он равен 1, то идет сброс всех ячеек памяти.
Внутри следующего блока выполняются операции pop, push, get. с помощью операции case выяснияем какая операция и делаем соответствующую операцию. Модулярная арифиетика выполнена проверкой условий. Если текущая ячейка указывает на 7, то я присваиваю ей значение 4, если значение 5, но присваиваю значение 0. 

получение значение из ячейки при get выполнено с помощью for. Заводим временную переменную со значением текущей ячейки и вычитаем из этого значения 1 нужное количество раз, попутно проверяя на условия модулярной арифметики, описанные выше.





> Раздел, в котором вы описываете свою реализацию:
> 
> Что за схема вам дана, как она работает.
> 
> Как она была реализована (сколько ячеек памяти вы по итогу использовали, как "под капотом" работает ваша схема).
> 
> Если в вашей схеме реализованы также (де)мультиплексоры, триггеры и прочие непростые логических схемы, то нужно также расписать как они работают и зачем были использованы (коротко: что это такое и принцип работы, можно приводить таблицы истинности и временные диаграммы).
> 
> Если реализуется normal, то нужно описать как работают входовыходы и работа с 5 ячейками памяти (учитывая, что индекс может принимать значения от 0 до 7 включительно).
> Отдельно описать особенности сборки на Logisim, отдельно – на SystemVerilog.

### Примечания по оформлению (можно удалить после создания отчёта)

1. Не нужно вставлять своё описание как quote (цитату). 
2. Старайтесь также разбивать ваш текст на логические разделы и отделять мысли заголовками.
3. Если хочется вставить фрагменты кода, то делаете это блоком кода. Если же ссылаетесь на код, то рекомендуется это делать через permalink на файлы в репозитории.
4. Можно пользоваться всеми возможностями Github Markdown.
5. Никаких фоток в отчёте, ровно как и скринов полного экрана. Это больно смотреть \(
6. Если вы хотите вставить изображение из сети, то не нужно его грузить в репозиторий.
7. В случае описание подсхем Logisim, если вы просто ссылаетесь на подсхему в целом, то достаточно указать назвнаие подсхемы из проекта. Если же вы описываете какой-то небольшой фрагмент схемы, то лучше его вставить в виде рисунка в отчёт.
